import json
import argparse
import math
import os

def sanitize_name(filename):
    """Creates a valid C++ variable name from a filename."""
    base = os.path.basename(filename)
    name, _ = os.path.splitext(base)
    # Replace invalid characters with underscores
    sanitized = ''.join(c if c.isalnum() else '_' for c in name)
    # Ensure it doesn't start with a digit
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    return sanitized if sanitized else 'map_data'

def compress_map(map_data):
    """Compresses a 3D boolean list into a list of bytes."""
    if not map_data or not map_data[0] or not map_data[0][0]:
        return [], 0, 0, 0 # Empty map

    size_z = len(map_data)
    size_y = len(map_data[0])
    size_x = len(map_data[0][0])

    flat_map = []
    for z in range(size_z):
        for y in range(size_y):
            for x in range(size_x):
                flat_map.append(map_data[z][y][x])

    compressed_data = []
    current_byte = 0
    bit_count = 0
    for i, is_wall in enumerate(flat_map):
        if is_wall:
            current_byte |= (1 << bit_count)

        bit_count += 1
        if bit_count == 8:
            compressed_data.append(current_byte)
            current_byte = 0
            bit_count = 0

    # Add the last byte if it's not full
    if bit_count > 0:
        compressed_data.append(current_byte)

    return compressed_data, size_x, size_y, size_z

def generate_cpp_header(maps_data, output_file):
    """Generates the C++ header file content without stdlib dependencies."""
    header_guard = f"GENERATED_{os.path.basename(output_file).upper().replace('.', '_')}_H"
    cpp_content = [
        f"#ifndef {header_guard}",
        f"#define {header_guard}",
        "",
        "// Automatically generated by convert.py script",
        "",
        "namespace WasmMaps {",
        "",
        "struct Vec3 {",
        "    int x;",
        "    int y;",
        "    int z;",
        "};",
        "",
        "// Template struct for map data, storing data internally using C-style array",
        "template <int DataSizeBytes>",
        "struct MapData {",
        "    int size_x;",
        "    int size_y;",
        "    int size_z;",
        "    Vec3 start;",
        "    unsigned char data[DataSizeBytes]; // Use C-style array with char type to hold 8 bits",
        "};",
        "",
        "// Map data instances",
    ]

    map_instance_names = []

    for map_info in maps_data:
        name = map_info['name']
        compressed_data = map_info['compressed_data']
        size_x = map_info['size_x']
        size_y = map_info['size_y']
        size_z = map_info['size_z']
        start = map_info['start']
        data_size_bytes = len(compressed_data)
        map_instance_names.append(f"{name}_map")

        # MapData struct instance definition using template and initializer list for C-style array
        data_array_init = ", ".join(f"0x{byte:02x}" for byte in compressed_data)
        map_struct_str = f"constexpr MapData<{data_size_bytes}> {name}_map = {{"
        map_struct_str += f"\n    .size_x = {size_x}, .size_y = {size_y}, .size_z = {size_z},"
        map_struct_str += f"\n    .start = {{ .x = {start['x']}, .y = {start['y']}, .z = {start['z']} }},"
        # Initializer list for C-style array
        map_struct_str += f"\n    .data = {{{data_array_init}}}"
        map_struct_str += f"\n}};"
        cpp_content.append(map_struct_str)
        cpp_content.append("")  # Add spacing

    # Add a list/array of pointers to all maps (if any maps were processed)
    if map_instance_names:
        cpp_content.append("// Structure to hold metadata and pointer for type erasure if needed")
        cpp_content.append("struct MapInfo {")
        cpp_content.append("    const char* name;")
        cpp_content.append("    int size_x;")
        cpp_content.append("    int size_y;")
        cpp_content.append("    int size_z;")
        cpp_content.append("    Vec3 start;")
        cpp_content.append("    const unsigned char* data_ptr;")
        cpp_content.append("    int data_size_bytes;")
        cpp_content.append("};")
        cpp_content.append("")
        cpp_content.append("// C-style array containing info for all generated maps")
        cpp_content.append(f"constexpr int ALL_MAPS_COUNT = {len(map_instance_names)};")
        # Use C-style array definition
        cpp_content.append("constexpr MapInfo all_maps[ALL_MAPS_COUNT] = {")
        for map_info in maps_data:
            name = map_info['name']
            instance_name = f"{name}_map"
            cpp_content.append(f"    {{")
            cpp_content.append(f"        .name = \"{name}\",")
            cpp_content.append(f"        .size_x = {instance_name}.size_x,")
            cpp_content.append(f"        .size_y = {instance_name}.size_y,")
            cpp_content.append(f"        .size_z = {instance_name}.size_z,")
            cpp_content.append(f"        .start = {instance_name}.start,")
            # Pointer to C-style array data
            cpp_content.append(f"        .data_ptr = {instance_name}.data,")
            # Size of C-style array data
            cpp_content.append(f"        .data_size_bytes = sizeof({instance_name}.data)")
            cpp_content.append(f"    }},")
        cpp_content.append("};")

    cpp_content.extend([
        "",
        "} // namespace WasmMaps",
        "",
        f"#endif // {header_guard}",
        ""
    ])

    with open(output_file, 'w') as f:
        f.write("\n".join(cpp_content))

def main():
    parser = argparse.ArgumentParser(description='Convert JSON map files to a C++ header.')
    parser.add_argument('-i', '--inputs', nargs='+', required=True,
                        help='Input JSON map file(s).')
    parser.add_argument('-o', '--output', required=True,
                        help='Output C++ header file path (e.g., src/wasm/maps.h).')

    args = parser.parse_args()

    all_maps_data = []

    for input_file in args.inputs:
        try:
            with open(input_file, 'r') as f:
                data = json.load(f)
        except FileNotFoundError:
            print(f"Error: Input file not found: {input_file}")
            continue
        except json.JSONDecodeError:
            print(f"Error: Could not decode JSON from file: {input_file}")
            continue

        if 'map' not in data or 'start' not in data:
            print(f"Warning: Skipping file {input_file} due to missing 'map' or 'start' key.")
            continue

        map_data = data['map']
        start_coords = data['start']

        compressed_data, size_x, size_y, size_z = compress_map(map_data)

        if size_x == 0:
             print(f"Warning: Skipping file {input_file} because map data is empty or invalid.")
             continue

        map_name = sanitize_name(input_file)

        all_maps_data.append({
            'name': map_name,
            'compressed_data': compressed_data,
            'size_x': size_x,
            'size_y': size_y,
            'size_z': size_z,
            'start': start_coords,
            'source_file': input_file
        })
        print(f"Processed {input_file} -> C++ var name: {map_name}")

    if not all_maps_data:
        print("No valid map data processed. Exiting.")
        return

    generate_cpp_header(all_maps_data, args.output)
    print(f"Successfully generated C++ header: {args.output}")

if __name__ == "__main__":
    main()
